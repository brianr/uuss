"""
Script to find and process datafiles generated by process_userstates.py

Usage:
python process_userstates_datafiles.py path/to/datadir
"""
from __future__ import with_statement

import logging
import optparse
import os
import re
import signal
import sys
import time

import sqlalchemy as sa

from paste.deploy import converters

from lolapps.util import processor

_user_state_pattern = re.compile(r'^user_state-modified-\d+-\d+\.\d+\.\d+\.user$')
_player_pattern = re.compile(r'^user_state-modified-\d+-\d+\.\d+\.\d+\.player$')

sleep_time = 0
file_dir = '.'
dane_us_connection = None
game = None
backup_processed_files = False

log = processor.configure_logging()

last_out = 0

def run_once():
    start_time = time.time()
    processed_file = False
    log.debug("checking for files")
    global last_out
    if last_out < time.time() - 60:
        last_out = time.time()
        log.info("blip")

    user_state_filename = find_file(_user_state_pattern)
    while user_state_filename:
        process_user_state_file(user_state_filename)
        processed_file = True
        user_state_filename = find_file(_user_state_pattern)

    if processed_file:
        proc_time = time.time() - start_time
        log.info("%s seconds to process all files" % proc_time)


def process_user_state_file(filename):
    """
    Process a single user state file.
    It's in LOAD DATA INFILE format, so all we have to do is do the load data infile.
    """
    full_filename = os.path.join(file_dir, filename)
    start_time = time.time()
    log.info("processing userstate file %s" % full_filename)

    # run the command
    try:
        sql = "LOAD DATA LOCAL INFILE '%s' REPLACE INTO TABLE user_state FIELDS OPTIONALLY ENCLOSED BY '\"' (user_id, state, date_created, date_modified, revision_id);" % full_filename
        dane_us_connection.execute(sql)

        proc_time = time.time() - start_time
        log.info("%s seconds to process userstate file" % proc_time)
    except Exception, e:
        log.exception(e)
        # save bad files for later
        os.rename(full_filename, full_filename+".bad")
    else:
        if backup_processed_files:
            backup_dir = os.path.join(file_dir, 'backup')
            if not os.path.exists(backup_dir):
                os.mkdir(backup_dir)
            os.rename(full_filename, os.path.join(backup_dir, filename))
        else:
            # it succeeded - remove the file
            os.unlink(full_filename)


def find_file(pattern):
    files = os.listdir(file_dir)
    for file in sorted(files):
        if pattern.match(file):
            return file
    return None


def print_usage():
    print "usage: python process_userstates_datafiles.py path/to/datadir"
    sys.exit(1)

def configure():
    global file_dir, dane_us_connection, sleep_time, game, backup_processed_files

    parser = optparse.OptionParser()
    parser.add_option("-s", "--sleep", dest="sleep", default="5", 
                      help="time to sleep between file searches")
    parser.add_option("-d", "--shard", dest="shard", default="0", help="shard to process")
    parser.add_option("-i", "--ini", dest="ini", help="uuss ini file")
    parser.add_option("-g", "--game", dest="game", help="game to process (dane, india)")
    parser.add_option("-b", "--backup", action="store_true", help="backup processed files")
    options, args = parser.parse_args()

    sleep_time = int(options.sleep)

    game = options.game
    if game is None:
        print "game option is required"
        sys.exit(1)

    ini_file = options.ini
    if ini_file is None:
        print "ini option is required"
        sys.exit(1)

    shard = int(options.shard)

    backup_processed_files = options.backup
    
    from uuss.server import configuration
    (full_config, config) = configuration.init_from_ini(ini_file, [game], {'uuss.use_gevent': False})

    file_dir = config["%s_user_state.tmp_dir%s" % (game, shard)]

    dane_us_write = config['sqlalchemy.%s_userstate%s.url' % (game, shard)]
    dane_us_connection = sa.create_engine(dane_us_write).connect()


def main():
    configure()

    import gc
    log.info("GC collected %r objects", gc.collect())
    
    while(True):
        try:
            run_once()
        except Exception, e:
            log.exception(e)
        time.sleep(sleep_time)

    #processor.register_signal_handlers()
    #processor.start_log_processor(run_once, 1)


if __name__ == '__main__':
    # TODO signal handlers
    main()
